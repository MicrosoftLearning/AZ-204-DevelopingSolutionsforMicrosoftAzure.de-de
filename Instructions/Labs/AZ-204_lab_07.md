---
lab:
  az204Title: 'Lab 07: Access resource secrets more securely across services'
  az020Title: 'Lab 07: Access resource secrets more securely across services'
  az204Module: 'Module 07: Implement secure cloud solutions'
  az020Module: 'Module 07: Implement secure cloud solutions'
ms.openlocfilehash: 4076ffe2afc66c9bfec1633fefe547a2fc713983
ms.sourcegitcommit: ddc44a8b5edc7ce2d93849bcab6c6a83dee1c99b
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 04/29/2022
ms.locfileid: "144404786"
---
# <a name="lab-07-access-resource-secrets-more-securely-across-services"></a>Lab 07: Sichererer dienstübergreifender Zugriff auf Ressourcengeheimnisse

## <a name="microsoft-azure-user-interface"></a>Microsoft Azure-Benutzeroberfläche

Aufgrund der dynamischen Natur der Microsoft-Cloudtools kann es vorkommen, dass sich die Azure-Benutzeroberfläche nach der Entwicklung dieses Trainingsinhalts ändert. Daher sind die Lab-Anweisungen und Lab-Schritte möglicherweise nicht mehr zutreffend.

Microsoft aktualisiert diesen Trainingskurs, wenn die Community uns auf notwendige Änderungen aufmerksam macht. Da Cloudupdates jedoch häufig vorkommen, können Änderungen an der Benutzeroberfläche möglicherweise auftreten, bevor diese Trainingsinhalte aktualisiert werden. **Wenn dies der Fall ist, stellen Sie sich auf die Veränderungen ein, und arbeiten Sie sie bei Bedarf in den Labs durch.**

## <a name="instructions"></a>Anweisungen

### <a name="before-you-start"></a>Vorbereitung

#### <a name="sign-in-to-the-lab-environment"></a>Anmelden bei der Laborumgebung

Melden Sie sich mit den folgenden Anmeldeinformationen bei Ihrer Windows 10-VM an:

- Benutzername: **Admin**
- Kennwort: **Pa55w.rd**

> **Hinweis**: Ihr Kursleiter stellt Anweisungen zum Herstellen einer Verbindung mit der virtuellen Laborumgebung zur Verfügung.

#### <a name="review-the-installed-applications"></a>Überprüfen der installierten Anwendungen

Suchen Sie auf Ihrem Windows 10-Desktop nach der Taskleiste. Die Taskleiste enthält die Symbole für die Anwendungen, die Sie in diesem Lab verwenden, darunter:

- Microsoft Edge
- Datei-Explorer
- Windows-Terminal
- Visual Studio Code

## <a name="architecture-diagram"></a>Architekturdiagramm

![Architekturdiagramm, das einen Benutzer zeigt, der dienstübergreifend sicherer auf Ressourcengeheimnisse zugreift.](./media/Lab07-Diagram.png)

### <a name="exercise-1-create-azure-resources"></a>Übung 1: Erstellen von Azure-Ressourcen

#### <a name="task-1-open-the-azure-portal"></a>Aufgabe 1: Öffnen des Azure-Portals

1. Wählen Sie auf der Taskleiste das Symbol **Microsoft Edge** aus.

1. Navigieren Sie im geöffneten Browserfenster zum Azure-Portal (<https://portal.azure.com>), und melden Sie sich dann mit dem Konto an, das Sie für dieses Lab verwenden werden.

    > **Hinweis**: Wenn Sie sich zum ersten Mal am Azure-Portal anmelden, wird Ihnen eine Tour durch das Portal angeboten. Wählen Sie **Erste Schritte** aus, um die Tour zu überspringen und mit der Verwendung des Portals zu beginnen.

#### <a name="task-2-create-a-storage-account"></a>Aufgabe 2: Erstellen eines Speicherkontos

1. Verwenden Sie im Azure-Portal das Textfeld **Ressourcen, Dienste und Dokumente durchsuchen**, um nach **Speicherkonten** zu suchen, und wählen Sie dann in der Ergebnisliste **Speicherkonten** aus.

1. Klicken Sie auf dem Blatt **Speicherkonten** auf **+ Erstellen**.

1. Führen Sie auf der Registerkarte **Grundlagen** des Blatts **Speicherkonto erstellen** die folgenden Aktionen aus, und wählen Sie **Überprüfen und erstellen** aus:

   | Einstellung | Aktion |
   | --- | --- |
   | Dropdownliste **Abonnement**   | Übernehmen Sie den Standardwert. |
   | Abschnitt **Ressourcengruppe**        | Wählen Sie **Neu erstellen** aus, geben Sie **ConfidentialStack** ein, und wählen Sie dann **OK** aus. |
   | Textfeld **Speicherkontoname** | Geben Sie **securestor** _[Ihr Name]_ ein. |
   | Dropdownliste **Region**         | Wählen Sie **USA, Osten** aus. |
   | Abschnitt **Leistung**           | Wählen Sie die Option **Standard** aus. |
   | Dropdownliste **Redundanz**     | Wählen Sie **Lokal redundanter Speicher (LRS)** aus. |

   Der folgende Screenshot zeigt die konfigurierten Einstellungen auf dem Blatt **Speicherkonto erstellen**.

   ![Screenshot, der die konfigurierten Einstellungen auf dem Blatt „Speicherkonto erstellen“ veranschaulicht](./media/l07_create_a_storage_account.png)

1. Überprüfen Sie auf der Registerkarte **Überprüfen und erstellen** die Optionen, die Sie in den vorherigen Schritten ausgewählt haben.

1. Wählen Sie **Erstellen** aus, um das Speicherkonto mithilfe Ihrer angegebenen Konfiguration zu erstellen.

    > **Hinweis**: Warten Sie, bis der Erstellungstask abgeschlossen ist, bevor Sie mit diesem Lab fortfahren.

1. Wählen Sie auf dem Blatt **Bereitstellungsübersicht** die Option **Zu Ressource wechseln** aus.

1. Wählen Sie auf dem Blatt **Speicherkonto** im Abschnitt **Sicherheit und Netzwerk** den Link **Zugriffsschlüssel** aus.

1. Wählen Sie im Abschnitt **Zugriffsschlüssel** die Option **Schlüssel anzeigen** aus.

1. Wählen Sie einen der Schlüssel aus, und notieren Sie sich den Wert in einem der Felder für **Verbindungszeichenfolge**. Sie verwenden diesen Wert später in diesem Lab.

    > **Hinweis**: Es spielt keine Rolle, welche Verbindungszeichenfolge Sie auswählen. Die Begriffe werden synonym verwendet.

#### <a name="task-3-create-an-azure-key-vault"></a>Aufgabe 3: Erstellen einer Azure Key Vault-Instanz

1. Verwenden Sie im Azure-Portal das Textfeld **Ressourcen, Dienste und Dokumente durchsuchen**, um nach **Schlüsseltresore** zu suchen. Wählen Sie in der Ergebnisliste dann **Schlüsseltresore** aus.

1. Wählen Sie auf dem Blatt **Schlüsseltresore** die Option **Erstellen** aus.

1.  Führen Sie auf der Registerkarte **Grundlagen** des Blatts **Schlüsseltresor erstellen** die folgenden Aktionen aus, und wählen Sie dann **Überprüfen und erstellen** aus:

    | Einstellung                           | Aktion                                    |
    | --------------------------------- | ----------------------------------------- |
    | Dropdownliste **Abonnement**   | Übernehmen Sie den Standardwert.                 |
    | Dropdownliste **Ressourcengruppe** | Wählen Sie in der Liste **ConfidentialStack** aus. |
    | Textfeld **Name des Schlüsseltresors**       | Geben Sie **securevault** _[Ihr Name]_ ein.        |
    | Dropdownliste **Region**         | Wählen Sie **USA, Osten** aus.                       |
    | Dropdownliste **Tarif**   | Wählen Sie **Standard** aus.                      |

    Der folgende Screenshot veranschaulicht die konfigurierten Einstellungen auf dem Blatt **Schlüsseltresor erstellen**.

    ![Screenshot mit den konfigurierten Einstellungen auf dem Blatt „Schlüsseltresor erstellen“](./media/l07_create_key_vault.png)

1. Überprüfen Sie auf der Registerkarte **Überprüfen und erstellen** die Optionen, die Sie in den vorherigen Schritten ausgewählt haben.

1. Wählen Sie **Erstellen** aus, um den Schlüsseltresor mit Ihrer angegebenen Konfiguration zu erstellen.

    > **Hinweis**: Warten Sie, bis der Erstellungstask abgeschlossen ist, bevor Sie mit diesem Lab fortfahren.

#### <a name="task-4-create-a-function-app"></a>Aufgabe 4: Erstellen einer Funktions-App

1. Verwenden Sie im Azure-Portal das Textfeld **Ressourcen, Dienste und Dokumente durchsuchen**, um nach **Funktions-App** zu suchen. Wählen Sie in der Ergebnisliste dann **Funktions-App** aus.

1. Wählen Sie auf dem Blatt **Funktions-App** die Option **Erstellen** aus.

1. Führen Sie auf dem Blatt **Funktions-App erstellen** auf der Registerkarte **Grundlagen** die folgenden Aktionen aus, und wählen Sie **Weiter: Hosting** aus:

    | Einstellung                           | Aktion                            |
    | --------------------------------- | --------------------------------- |
    | Dropdownliste **Abonnement**   | Übernehmen Sie den Standardwert.         |
    | Dropdownliste **Ressourcengruppe** | Wählen Sie **ConfidentialStack** aus.     |
    | Textfeld **Funktions-App-Name**    | Geben Sie **securefunc** _[Ihr Name]_ ein. |
    | Abschnitt **Veröffentlichen**               | Wählen Sie **Code** aus. |
    | Dropdownliste **Laufzeitstapel**  | Wählen Sie **.NET** aus. |
    | Dropdownliste **Version**        | Wählen Sie **3.1** aus. |
    | Dropdownliste **Region**         | Wählen Sie die Region **USA, Osten** aus. |

    Der folgende Screenshot veranschaulicht die konfigurierten Einstellungen auf dem Blatt **Funktions-App erstellen**.

    ![Screenshot mit den konfigurierten Einstellungen auf Blatt „Funktions-App erstellen“.](./media/l07_create_function_app.png)

1. Führen Sie auf der Registerkarte **Hosting** die folgenden Aktionen aus, und wählen Sie dann **Überprüfen + erstellen** aus:

    | Einstellung | Aktion |
    | --- | --- |
    | Dropdownliste **Speicherkonto** | Wählen Sie das Speicherkonto **securestor** _[Ihr Name]_ aus. |
    | Abschnitt **Betriebssystem**       | Wählen Sie **Linux** aus. |
    | Dropdownliste **Plantyp**       | Wählen Sie **Verbrauch (Serverlos)** aus. |

    Der folgende Screenshot veranschaulicht die konfigurierten Einstellungen auf der Registerkarte **Hosting** auf dem Blatt **Funktions-App erstellen**.

    ![Screenshot der konfigurierten Einstellungen auf der Registerkarte „Hosting“ auf dem Blatt „Funktions-App erstellen“. ](./media/l07_create_function_app_hosting_tab.png)

1. Überprüfen Sie auf der Registerkarte **Überprüfen und erstellen** die Optionen, die Sie in den vorherigen Schritten ausgewählt haben.

1. Wählen Sie **Erstellen** aus, um die Funktions-App mit Ihrer angegebenen Konfiguration zu erstellen.

    > **Hinweis**: Warten Sie, bis der Erstellungstask abgeschlossen ist, bevor Sie mit diesem Lab fortfahren.

#### <a name="review"></a>Überprüfung

In dieser Übung haben Sie alle Ressourcen erstellt, die Sie in diesem Lab verwenden werden.

### <a name="exercise-2-configure-secrets-and-identities"></a>Übung 2: Konfigurieren von Geheimnissen und Identitäten

#### <a name="task-1-configure-a-system-assigned-managed-service-identity"></a>Aufgabe 1: Konfigurieren einer systemseitig zugewiesenen verwalteten Dienstidentität

1. Wählen Sie im Navigationsbereich des Azure-Portals den Link **Ressourcengruppen** aus.

1. Wählen Sie auf dem Blatt **Ressourcengruppen** die Ressourcengruppe **ConfidentialStack** aus.

1. Wählen Sie auf dem Blatt **ConfidentialStack** die Funktions-App **securefunc** _[Ihr Name]_ aus.

    > **Hinweis**: Es gibt zwei Ressourcen, eine Funktions-App und eine Application Insights-Ressource mit dem gleichen Namen. Stellen Sie sicher, dass Sie die Funktions-App-Ressource auswählen.

1. Wählen Sie auf dem Blatt **Funktions-App** die Option **Identität** im Abschnitt **Einstellungen** aus.

1. Legen Sie im Bereich **Identität** auf der Registerkarte **Systemseitig zugewiesen** den **Status** auf **Ein** fest, und wählen Sie dann **Speichern** aus.

1. Wählen Sie **Ja** aus, um die Einstellung zu bestätigen.

    > **Hinweis** Warten Sie, bis die systemseitig zugewiesene verwaltete Identität erstellt wurde, bevor Sie mit diesem Lab fortfahren.

#### <a name="task-2-create-a-key-vault-secret"></a>Aufgabe 2: Erstellen eines Key Vault-Geheimnisses

1. Wählen Sie im **Navigations** bereich des Azure-Portals den Link **Ressourcengruppen** aus.

1. Wählen Sie auf dem Blatt **Ressourcengruppen** die Ressourcengruppe **ConfidentialStack** aus.

1. Wählen Sie auf dem Blatt **ConfidentialStack** den Schlüsseltresor **securevault** _[Ihr Name]_ aus.

1. Wählen Sie auf dem Blatt **Key Vault** den Link **Geheimnisse** im Abschnitt **Einstellungen** aus.

1. Wählen Sie im Bereich **Geheimnis** die Option **+ Generieren/importieren** aus.

1. Führen Sie auf dem Blatt **Geheimnis erstellen** die folgenden Aktionen aus, und wählen Sie dann **Erstellen** aus:

    | Einstellung | Aktion |
    | --- |  --- |
    | Dropdownliste **Uploadoptionen** | Wählen Sie **Manuell** aus. |
    | Textfeld **Name**       | Geben Sie **storagecredentials** ein. |
    | Textfeld **Wert**       | Geben Sie die Verbindungszeichenfolge für das Speicherkonto ein, die Sie zuvor in diesem Lab notiert haben.               |
    | Textfeld **Inhaltstyp** | Lassen Sie dieses Feld leer. |
    | Kontrollkästchen **Aktivierungsdatum festlegen** | Nicht ausgewählt. |
    | Kontrollkästchen **Ablaufdatum festlegen** | Nicht ausgewählt. |
    | Option **Aktiviert** | Wählen Sie **Ja**. |

    Der folgende Screenshot veranschaulicht die konfigurierten Einstellungen auf dem Blatt **Geheimnis erstellen**.

    ![Screenshot mit den konfigurierten Einstellungen auf dem Blatt „Geheimnis erstellen“ ](./media/l07_create_a_secret.png)

    > **Hinweis**: Warten Sie, bis das Geheimnis erstellt wurde, bevor Sie mit diesem Lab fortfahren.

1. Kehren Sie zum Bereich **Geheimnisse** zurück, und wählen Sie dann das Element **storagecredentials** in der Liste aus.

1. Wählen Sie im Bereich **Versionen** die neueste Version des Geheimnisses **storagecredentials** aus.

1. Führen Sie im Bereich **Geheimnisversion** die folgenden Aktionen aus:

    1. Wählen Sie **Geheimniswert anzeigen** aus, um den Wert des Geheimnisses zu suchen.

    1. Zeichnen Sie den Wert des Textfelds **Geheimnis-ID** auf, da Sie diesen später im Lab verwenden.

    > **Hinweis**: Sie erfassen den Wert des Textfelds **Geheimnis-ID**, nicht das Textfeld **Geheimniswert**.

#### <a name="task-3-configure-a-key-vault-access-policy"></a>Aufgabe 3: Konfigurieren einer Key Vault-Zugriffsrichtlinie

1. Wählen Sie im Navigationsbereich des Azure-Portals den Link **Ressourcengruppen** aus.

1. Wählen Sie auf dem Blatt **Ressourcengruppen** die Ressourcengruppe **ConfidentialStack** aus.

1. Wählen Sie auf dem Blatt **ConfidentialStack** den Schlüsseltresor **securevault[Ihr Name]** aus.

1. Wählen Sie auf dem Blatt **Key Vault** den Link **Zugriffsrichtlinien** im Abschnitt **Einstellungen** aus.

1. Wählen Sie im Bereich **Zugriffsrichtlinien** die Option **Zugriffsrichtlinie hinzufügen** aus.

1. Führen Sie auf dem Blatt **Zugriffsrichtlinie hinzufügen** die folgenden Aktionen aus, und wählen Sie dann **Hinzufügen** aus:

    | Einstellung | Aktion |
    | --- | --- |
    | Dropdownliste **Anhand einer Vorlage konfigurieren** | Nicht ausfüllen |
    | Dropdownliste **Schlüsselberechtigungen** | 0 ausgewählt |
    | Dropdownliste **Geheimnisberechtigungen** | Wählen Sie die **GET**-Berechtigung aus. |
    | Dropdownliste **Zertifikatberechtigungen** | 0 ausgewählt |
    | Link **Prinzipal auswählen** | Suchen Sie den Dienstprinzipal **securefunc** _[Ihr Name]_ , und wählen Sie ihn aus. Die systemseitig zugewiesene verwaltete Identität, die Sie zuvor in diesem Lab erstellt haben, hat den gleichen Namen wie die Azure Function-Ressource. |
    | Link **Autorisierte Anwendung** | Keine Auswahl. |

    Der folgende Screenshot veranschaulicht die konfigurierten Einstellungen auf dem Blatt **Zugriffsrichtlinie hinzufügen**.

    ![Screenshot, der die konfigurierten Einstellungen auf dem Blatt „Zugriffsrichtlinie hinzufügen“ veranschaulicht](./media/l07_add_access_policy.png)

1. Wählen Sie im Bereich **Zugriffsrichtlinien** die Option **Speichern** aus.

    > **Hinweis**: Warten Sie, bis Ihre Änderungen an den Zugriffsrichtlinien gespeichert sind, bevor Sie mit diesem Lab fortfahren.

#### <a name="task-4-create-a-key-vault-derived-application-setting"></a>Aufgabe 4: Erstellen einer von Key Vault abgeleiteten Anwendungseinstellung

1. Wählen Sie im Navigationsbereich des Azure-Portals den Link **Ressourcengruppen** aus.

1. Wählen Sie auf dem Blatt **Ressourcengruppen** die Ressourcengruppe **ConfidentialStack** aus.

1. Wählen Sie auf dem Blatt **ConfidentialStack** die Funktions-App **securefunc[Ihr Name]** aus.

1. Wählen Sie auf dem Blatt **Funktions-App** die Option **Konfiguration** im Abschnitt **Einstellungen** aus.

1. Wählen Sie im Bereich **Konfiguration** auf der Registerkarte **Anwendungseinstellungen** die Option **Neue Anwendungseinstellung** aus.

1. Geben Sie im Popupfenster **Anwendungseinstellung hinzufügen/bearbeiten** in das Textfeld **Name** den Wert **StorageConnectionString** ein.

1. Erstellen Sie im Textfeld **Wert** einen Wert, indem Sie die folgende Syntax verwenden: ``@Microsoft.KeyVault(SecretUri=*Secret Identifier*)``

    > **Hinweis**: Sie müssen einen Verweis auf Ihre **_Geheimnis-ID_** mithilfe der obigen Syntax erstellen. Wenn Ihre Geheimnis-ID z. B. `https://securevaultstudent.vault.azure.net/secrets/storagecredentials/17b41386df3e4191b92f089f5efb4cbf` lautet, wäre Ihr Wert `@Microsoft.KeyVault(SecretUri=https://securevaultstudent.vault.azure.net/secrets/storagecredentials/17b41386df3e4191b92f089f5efb4cbf)`.

1. Belassen Sie das Kontrollkästchen **Bereitstellungssloteinstellung** auf seinem Standardwert (nicht aktiviert), und wählen Sie dann **OK** aus, um das Popupfenster zu schließen und zum Abschnitt **Konfiguration** zurückzukehren.

1. Wählen Sie **Speichern** aus, um Ihre Einstellungen zu speichern, und wählen Sie dann im Popupfenster **Änderungen speichern** zur Bestätigung **Fortfahren** aus.

    > **Hinweis**: Warten Sie, bis Ihre Anwendungseinstellungen gespeichert sind, bevor Sie mit dem Lab fortfahren.

#### <a name="review"></a>Überprüfung

In dieser Übung haben Sie eine systemseitig zugewiesene verwaltete Dienstidentität für Ihre Funktions-App erstellt und dieser Identität dann die entsprechenden Berechtigungen erteilt, um den Wert eines Geheimnisses in Ihrem Schlüsseltresor abzurufen. Schließlich haben Sie ein Geheimnis erstellt, auf das Sie in den Konfigurationseinstellungen Ihrer Funktions-App verweisen.

### <a name="exercise-3-build-an-azure-functions-app"></a>Übung 3: Erstellen einer Azure Functions-App

#### <a name="task-1-initialize-a-function-project"></a>Aufgabe 1: Initialisieren eines Funktionsprojekts

1. Wählen Sie auf der Taskleiste das Symbol **Windows-Terminal** aus.

1. Führen Sie den folgenden Befehl aus, um vom aktuellen Verzeichnis in das leere Verzeichnis **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** zu wechseln:

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

    > **Hinweis**: Entfernen Sie in Windows-Explorer das schreibgeschützte Attribut aus der Datei „F:\Allfiles\Labs\07\Starter\func\.gitignore“.

1. Führen Sie den folgenden Befehl aus, um mithilfe der **Azure Functions Core Tools** und unter Verwendung der **dotnet**-Runtime ein neues lokales Functions-Projekt im aktuellen Verzeichnis zu erstellen:

    ```powershell
    func init --worker-runtime dotnet --force
    ```

    > **Hinweis**: Sie können die Dokumentation zum [Erstellen eines neuen Projekts][azure-functions-core-tools-new-project] mithilfe der **Azure Functions Core Tools** lesen.

1. Führen Sie den folgenden Befehl aus, um das .NET Core 3.1-Projekt zu **erstellen**:

    ```powershell
    dotnet build
    ```

#### <a name="task-2-create-an-http-triggered-function"></a>Aufgabe 2: Erstellen einer durch HTTP ausgelösten Funktion

1. Führen Sie den folgenden Befehl aus, um die **Azure Functions Core Tools** zu verwenden, um mithilfe der **HTTP-Trigger**-Vorlage eine neue Funktion namens **FileParser** zu erstellen:

    ```powershell
    func new --template "HTTP trigger" --name "FileParser"
    ```

    > **Hinweis**: Sie können die Dokumentation zum [Erstellen einer neuen Funktion][azure-functions-core-tools-new-function] mithilfe der **Azure Functions Core Tools** lesen.

1. Schließen Sie die aktuell ausgeführte **Windows-Terminal**-Anwendung.

#### <a name="task-3-configure-and-read-an-application-setting"></a>Aufgabe 3: Konfigurieren und Lesen einer Anwendungseinstellung

1. Wählen Sie auf dem **Startbildschirm** die Kachel **Visual Studio Code** aus.

1. Klicken Sie im Menü **Datei** auf **Ordner öffnen**.

1. Suchen Sie im Fenster **Datei-Explorer**, das geöffnet wird, nach **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func**, und wählen Sie dann **Ordner auswählen** aus.

1. Öffnen Sie im **Explorer**-Bereich des **Visual Studio Code**-Fensters die Datei **local.settings.json**.

1. Beobachten Sie den aktuellen Wert des **Values**-Objekts:

    ```json
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet"
    }
    ```

1. Aktualisieren Sie den Wert des **Values**-Objekts, indem Sie eine neue Einstellung namens **StorageConnectionString** hinzufügen und ihr dann den Zeichenfolgenwert **[TESTWERT]** zuweisen:

    ```json
    "Values": {
        "AzureWebJobsStorage": "UseDevelopmentStorage=true",
        "FUNCTIONS_WORKER_RUNTIME": "dotnet",
        "StorageConnectionString": "[TEST VALUE]"
    }
    ```

1. Die Datei **local.settings.json** sollte jetzt Folgendes enthalten:

    ```json
    {
        "IsEncrypted": false,
        "Values": {
            "AzureWebJobsStorage": "UseDevelopmentStorage=true",
            "FUNCTIONS_WORKER_RUNTIME": "dotnet",
            "StorageConnectionString": "[TEST VALUE]"
        }
    }
    ```

1. Wählen Sie **Speichern** aus, um Ihre Änderungen in der Datei **local.settings.json** zu speichern.

1. Öffnen Sie im **Explorer**-Bereich des **Visual Studio Code**-Fensters die Datei **FileParser.cs**.

1. Sehen Sie sich im Code-Editor die Beispielimplementierung an:

    ```csharp
    using System;
    using System.IO;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.Azure.WebJobs.Extensions.Http;
    using Microsoft.AspNetCore.Http;
    using Microsoft.Extensions.Logging;
    using Newtonsoft.Json;
    namespace func
    {
        public static class FileParser
        {
            [FunctionName("FileParser")]
            public static async Task<IActionResult> Run(
                [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
                ILogger log)
            {
                log.LogInformation("C# HTTP trigger function processed a request.");
                string name = req.Query["name"];
                string requestBody = await new StreamReader(req.Body).ReadToEndAsync();
                dynamic data = JsonConvert.DeserializeObject(requestBody);
                name = name ?? data?.name;
                string responseMessage = string.IsNullOrEmpty(name)
                    ? "This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response."
                    : $"Hello, {name}. This HTTP triggered function executed successfully.";
                return new OkObjectResult(responseMessage);
            }
        }
    }
    ```

1. Löschen Sie den gesamten Inhalt der Datei **FileParser.cs**.

1. Fügen Sie die folgenden Codezeilen hinzu, um **using-Anweisungen** für die Namespaces **Microsoft.AspNetCore.Mvc**, **Microsoft.Azure.WebJobs**, **Microsoft.AspNetCore.Http**, **System** und **System.Threading.Tasks** hinzuzufügen:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    ```

1. Erstellen Sie eine neue **öffentliche statische** Klasse namens **FileParser**:

    ```csharp
    public static class FileParser
    { }
    ```

1. Sehen Sie sich die Datei **FileParser.cs** erneut an, die nun Folgendes enthalten sollte:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    { }
    ```

1. Fügen Sie innerhalb der Klasse **FileParser** den folgenden Codeblock hinzu, um eine neue **öffentliche statische** *asynchrone* Methode namens **Run** zu erstellen. Diese Methode gibt eine Variable vom Typ **Task\<IActionResult\>** zurück und nimmt außerdem eine Variable vom Typ **HttpRequest** namens *request* auf:

    ```csharp
    public static async Task<IActionResult> Run(
        HttpRequest request)
    { }
    ```

1. Fügen Sie den folgenden Code hinzu, um der **Run**-Methode des Typs **FunctionNameAttribute** ein Attribut hinzuzufügen, dessen **name**-Parameter auf den Wert **FileParser** festgelegt ist:

    ```csharp
    [FunctionName("FileParser")]
    public static async Task<IActionResult> Run(
        HttpRequest request)
    { }
    ```

1. Fügen Sie den folgenden Code hinzu, um dem **request**-Parameter des Typs **HttpTriggerAttribute** ein Attribut hinzuzufügen, dessen **methods**-Parameterarray auf den einzelnen Wert **GET** festgelegt ist:

    ```csharp
    [FunctionName("FileParser")]
    public static async Task<IActionResult> Run(
        [HttpTrigger("GET")] HttpRequest request)
    { }
    ```

1. Sehen Sie sich die Datei **FileParser.cs** erneut an, die nun Folgendes enthalten sollte:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        { }
    }
    ```

1. Geben Sie in der **Run**-Methode die folgende Codezeile ein, um den Wert der Anwendungseinstellung **StorageConnectionString** mithilfe der **Environment.GetEnvironmentVariable**-Methode abzurufen und das Ergebnis in einer **string**-Variablen namens **connectionString** zu speichern:

    ```csharp
    string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
    ```

1. Geben Sie die folgende Codezeile ein, um den Wert der **connectionString**-Variablen als HTTP-Antwort zurückzugeben:

    ```csharp
    return new OkObjectResult(connectionString);
    ```

1. Sehen Sie sich die Datei **FileParser.cs** erneut an, die nun Folgendes enthalten sollte:

    ```csharp
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            return new OkObjectResult(connectionString);
        }
    }
    ```

1. Wählen Sie **Speichern** aus, um Ihre Änderungen in der Datei **FileParser.cs** zu speichern.

#### <a name="task-4-validate-the-local-function"></a>Aufgabe 4: Überprüfen der lokalen Funktion

1. Wählen Sie auf der Taskleiste das Symbol **Windows-Terminal** aus.

1. Führen Sie den folgenden Befehl aus, um vom aktuellen Verzeichnis in das leere Verzeichnis **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** zu wechseln:

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. Führen Sie den folgenden Befehl aus, um das Funktions-App-Projekt auszuführen:

    ```powershell
    func start --build
    ```

    > **Hinweis**: Sie können die Dokumentation zum [lokalen Starten des Funktions-App-Projekts][azure-functions-core-tools-start-function] mithilfe der **Azure Functions Core Tools** lesen.

1. Wählen Sie auf der Taskleiste erneut das Symbol **Windows-Terminal** aus, um eine neue Instanz der Anwendung **Windows-Terminal** zu öffnen. Führen Sie den folgenden Befehl aus, um vom aktuellen Verzeichnis in das leere Verzeichnis **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** zu wechseln:

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```
    
1. Wenn Ihnen die geöffnete Eingabeaufforderung angezeigt wird, führen Sie den folgenden Befehl aus, um das **httprepl**-Tool zu starten, wobei Sie den Basis-URI (Uniform Resource Identifier) auf ``http://localhost:7071`` festlegen:

    ```powershell
    httprepl http://localhost:7071
    ```

    > **Hinweis**: Das **httprepl**-Tool zeigt eine Fehlermeldung an. Zu dieser Meldung kommt es, weil das Tool nach einer Swagger-Definitionsdatei sucht, die zum Durchlaufen der API verwendet werden soll. Da Ihr Funktionsprojekt keine Swagger-Definitionsdatei erzeugt, müssen Sie die API manuell durchlaufen.
1. Wenn die Eingabeaufforderung des Tools angezeigt wird, führen Sie den folgenden Befehl aus, um zum relativen **api**-Verzeichnis zu wechseln:

    ```powershell
    cd api
    ```

1. Führen Sie den folgenden Befehl aus, um zum relativen **fileparser**-Verzeichnis zu wechseln:

    ```powershell
    cd fileparser
    ```

1. Führen Sie den folgenden Befehl aus, um den **get**-Befehl auszuführen:

    ```powershell
    get
    ```

1. Beobachten Sie den **[TESTWERT]** -Wert von **StorageConnectionString**, der als Ergebnis der HTTP-Anforderung zurückgegeben wird:

    ```powershell
    HTTP/1.1 200 OK
    Content-Type: text/plain; charset=utf-8
    Date: Tue, 01 Sep 2020 23:35:39 GMT
    Server: Kestrel
    Transfer-Encoding: chunked
    [TEST VALUE]
    ```

1. Führen Sie den folgenden Befehl aus, um das **httprepl**-Tool zu beenden:

    ```powershell
    exit
    ```

1. Schließen Sie alle aktuell ausgeführten Instanzen der **Windows-Terminal**-Anwendung.

#### <a name="task-5-deploy-the-function-using-the-azure-functions-core-tools"></a>Aufgabe 5: Bereitstellen der Funktion mithilfe der Azure Functions Core Tools

1. Wählen Sie auf der Taskleiste das Symbol **Windows-Terminal** aus.

1. Führen Sie den folgenden Befehl aus, um vom aktuellen Verzeichnis in das leere Verzeichnis **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** zu wechseln:

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. Führen Sie den folgenden Befehl aus, um sich bei der Azure-Befehlszeilenschnittstelle (CLI) anzumelden:

    ```powershell
    az login
    ```

1. Geben Sie im **Microsoft Edge**-Browserfenster die E-Mail-Adresse und das Kennwort für Ihr Microsoft-Konto ein, und wählen Sie dann **Anmelden** aus.

1. Kehren Sie zum derzeit geöffneten **Windows-Terminal**-Fenster zurück. Warten Sie, bis der Anmeldevorgang abgeschlossen ist.

1. Führen Sie den folgenden Befehl aus, um das Funktions-App-Projekt zu veröffentlichen:

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > **Hinweis**: Wenn Ihr **Funktions-App-Name** beispielsweise **securefuncstudent** lautet, wäre Ihr Befehl ``func azure functionapp publish securefuncstudent``. Sie können die Dokumentation zum [Veröffentlichen des lokalen Funktions-App-Projekts][azure-functions-core-tools-publish-azure] mithilfe der **Azure Functions Core Tools** lesen.

1. Warten Sie, bis die Bereitstellung fertig gestellt ist, bevor Sie mit dem Lab fortfahren.

1. Schließen Sie die aktuell ausgeführte **Windows-Terminal**-Anwendung.

#### <a name="task-6-test-the-key-vault-derived-application-setting"></a>Aufgabe 6: Testen der von Key Vault abgeleiteten Anwendungseinstellung

1. Wählen Sie auf der Taskleiste das Symbol **Microsoft Edge** aus, und wählen Sie dann die Registerkarte aus, die das Azure-Portal (<https://portal.azure.com>) enthält.

1. Wählen Sie im Navigationsbereich des Azure-Portals den Link **Ressourcengruppen** aus.

1. Wählen Sie auf dem Blatt **Ressourcengruppen** die Ressourcengruppe **ConfidentialStack** aus.

1. Wählen Sie auf dem Blatt **ConfidentialStack** die Funktions-App **securefunc[Ihr Name]** aus.

1. Wählen Sie auf dem Blatt **Funktions-App** im Abschnitt **Funktionen** die Option **Funktionen** aus.

1. Wählen Sie im Bereich **Funktionen** die vorhandene **FileParser**-Funktion aus.

1. Wählen Sie auf dem Blatt **Funktion** im Abschnitt **Entwickler** die Option **Programmieren und testen** aus.

1. Wählen Sie im Funktionen-Editor **Testen/Ausführen** aus.

1. Wählen Sie im angezeigten Popupdialogfeld in der Liste **HTTP-Methode** die Option **GET** aus.

1. Wählen Sie **Ausführen** aus, um die Funktion zu testen.

1. Sehen Sie sich die Ergebnisse des Testlaufs an. Das Ergebnis sollte Ihre Azure Storage-Verbindungszeichenfolge sein.

#### <a name="review"></a>Überprüfung

In dieser Übung haben Sie eine Dienstidentität verwendet, um den Wert eines in Key Vault gespeicherten Geheimnisses zu lesen und diesen Wert als Ergebnis einer Funktions-App zurückzugeben.

### <a name="exercise-4-access-azure-blob-storage-data"></a>Übung 4: Zugreifen auf Azure Blob Storage-Daten

#### <a name="task-1-upload-a-sample-storage-blob"></a>Aufgabe 1: Hochladen eines Beispielspeicherblobs

1. Wählen Sie im Navigationsbereich des Azure-Portals den Link **Ressourcengruppen** aus.

1. Wählen Sie auf dem Blatt **Ressourcengruppen** die Ressourcengruppe **ConfidentialStack** aus.

1. Wählen Sie auf dem Blatt **ConfidentialStack** das Speicherkonto **securestor** _[Ihr Name]_ aus.

1. Wählen Sie auf dem Blatt **Speicherkonto** den Link **Container** im Abschnitt **Datenspeicher** aus.

1. Wählen Sie im Abschnitt **Container** die Option **+ Container** aus.

1. Führen Sie im Popupfenster **Neuer Container** die folgenden Aktionen aus, und wählen Sie dann **Erstellen** aus:

    | Einstellung | Aktion |
    | --- | --- |
    | Textfeld **Name** | Geben Sie **drop** ein. |
    | Dropdownliste **Öffentliche Zugriffsebene** | Wählen Sie **Blob (anonymer Lesezugriff nur für Blobs)** aus. |

1. Kehren Sie zum Abschnitt **Container** zurück, und wählen Sie dann den neu erstellten Container **drop** aus.

1. Wählen Sie auf dem Blatt **Container** die Option **Hochladen** aus.

1. Führen Sie im Fenster **Blob hochladen** die folgenden Aktionen aus, und wählen Sie dann **Hochladen** aus:

    | Einstellung | Aktion |
    | --- | --- |
    | Abschnitt **Dateien** | Wählen Sie das Symbol **Ordner** aus. |
    | Fenster **Datei-Explorer** | Wechseln Sie zu **Allfiles (F):\\Allfiles\\Labs\\07\\Starter**, und wählen Sie zuerst die Datei **records.json** und dann **Öffnen** aus. |
    | Kontrollkästchen **Überschreiben, falls Dateien bereits vorhanden sind** | Stellen Sie sicher, dass dieses Kontrollkästchen aktiviert ist. |

    > **Hinweis**: Warten Sie, bis das Blob hochgeladen wurde, bevor Sie mit diesem Lab fortfahren.

1. Kehren Sie zum Blatt **Container** zurück, und wählen Sie dann das Blob **records.json** in der Liste der Blobs aus.

1. Suchen Sie auf dem Blatt **Blob** nach den Blobmetadaten, und kopieren Sie dann die URL für das Blob.

1. Aktivieren Sie auf der Taskleiste das Kontextmenü für das **Microsoft Edge**-Symbol, und wählen Sie dann **Neues Fenster** aus.

1. Verweisen Sie in dem neuen Browserfenster auf die URL, die Sie für das Blob kopiert haben.

1. Der JSON-Inhalt (JavaScript Object Notation) des Blobs sollte jetzt angezeigt werden. Schließen Sie das Browserfenster mit den JSON-Inhalten.

1. Kehren Sie zum Browserfenster mit dem Azure-Portal zurück, und schließen Sie dann das Blatt **Blob**.

1. Kehren Sie zum Blatt **Container** zurück, und wählen Sie dann **Zugriffsebene ändern** aus.

1. Führen Sie im Popupfenster **Zugriffsebene ändern** die folgenden Aktionen aus:

    1. Wählen Sie in der Dropdownliste **Öffentliche Zugriffsebene** die Option **Privat (kein anonymer Zugriff)** aus.

    1. Klicken Sie auf **OK**.

1. Aktivieren Sie auf der Taskleiste das Kontextmenü für das **Microsoft Edge**-Symbol, und wählen Sie dann **Neues Fenster** aus.

1. Verweisen Sie in dem neuen Browserfenster auf die URL, die Sie für das Blob kopiert haben.

1. Es sollte nun eine Fehlermeldung angezeigt werden, die angibt, dass die Ressource nicht gefunden wurde.

    > **Hinweis**: Wenn die Fehlermeldung nicht angezeigt wird, hat Ihr Browser die Datei möglicherweise zwischengespeichert. Wählen Sie STRG+F5 aus, um die Seite zu aktualisieren, bis die Fehlermeldung angezeigt wird.

#### <a name="task-2-pull-and-configure-the-azure-sdk-for-net"></a>Aufgabe 2: Pullen und Konfigurieren des Azure SDK für .NET

1. Wählen Sie auf der Taskleiste das Symbol **Windows-Terminal** aus.

1. Führen Sie den folgenden Befehl aus, um vom aktuellen Verzeichnis in das leere Verzeichnis **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** zu wechseln:

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. Führen Sie den folgenden Befehl aus, um Version **12.6.0** des **Azure.Storage.Blobs**-Pakets aus NuGet hinzuzufügen:

    ```powershell
    dotnet add package Azure.Storage.Blobs --version 12.6.0
    ```

    > **Hinweis**: Das NuGet-Paket [Azure.Storage.Blobs](https://www.nuget.org/packages/Azure.Storage.Blobs/12.6.0) verweist auf die Teilmenge des Azure SDK für .NET, die zum Schreiben von Code für Azure Blob Storage erforderlich ist.

1. Schließen Sie die aktuell ausgeführte **Windows-Terminal**-Anwendung.

1. Wählen Sie auf dem **Startbildschirm** die Kachel **Visual Studio Code** aus.

1. Klicken Sie im Menü **Datei** auf **Ordner öffnen**.

1. Suchen Sie im Fenster **Datei-Explorer**, das geöffnet wird, nach **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func**, und wählen Sie dann **Ordner auswählen** aus.

1. Öffnen Sie im **Explorer**-Bereich des **Visual Studio Code**-Fensters die Datei **FileParser.cs**.

1. Fügen Sie eine **using-Anweisung** für den **Azure.Storage.Blobs**-Namespace hinzu:

    ```csharp
    using Azure.Storage.Blobs;
    ```

1. Sehen Sie sich die Datei **FileParser.cs** an, die nun Folgendes enthalten sollte:

    ```csharp
    using Azure.Storage.Blobs;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            return new OkObjectResult(connectionString);
        }
    }
    ```

#### <a name="task-3-write-azure-blob-storage-code-using-the-azure-sdk-for-net"></a>Aufgabe 3: Schreiben von Azure Blob Storage-Code mit dem Azure SDK für .NET

1. Löschen Sie innerhalb der **Run**-Methode der **FileParser**-Klasse die folgende Codezeile:

    ```csharp
    return new OkObjectResult(connectionString);
    ```

1. Fügen Sie noch innerhalb der **Run**-Methode den folgenden Codeblock hinzu, um eine neue Instanz der **BlobClient**-Klasse zu erstellen, indem Sie Ihre *connectionString*-Variable, einen ``"drop"``-Zeichenfolgenwert und einen ``"records.json"``-Zeichenfolgenwert an den Konstruktor übergeben:

    ```csharp
    BlobClient blob = new BlobClient(connectionString, "drop", "records.json");
    ```

1. Fügen Sie noch innerhalb der **Run**-Methode den folgenden Codeblock hinzu, um die **BlobClient.DownloadAsync**-Methode zu verwenden, um den Inhalt des referenzierten Blobs asynchron herunterzuladen und das Ergebnis in einer Variablen namens *response* zu speichern:

    ```csharp
    var response = await blob.DownloadAsync();
    ```

1. Fügen Sie noch innerhalb der **Run**-Methode den folgenden Codeblock hinzu, um den Wert der verschiedenen in der *content*-Variablen gespeicherten Inhalte zurückzugeben, indem Sie den Konstruktor der **FileStreamResult**-Klasse verwenden:

    ```csharp
    return new FileStreamResult(response?.Value?.Content, response?.Value?.ContentType);
    ```

1. Sehen Sie sich die Datei **FileParser.cs** erneut an, die nun Folgendes enthalten sollte:

    ```csharp
    using Azure.Storage.Blobs;
    using Microsoft.AspNetCore.Mvc;
    using Microsoft.Azure.WebJobs;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Threading.Tasks;
    public static class FileParser
    {
        [FunctionName("FileParser")]
        public static async Task<IActionResult> Run(
            [HttpTrigger("GET")] HttpRequest request)
        {
            string connectionString = Environment.GetEnvironmentVariable("StorageConnectionString");
            BlobClient blob = new BlobClient(connectionString, "drop", "records.json");
            var response = await blob.DownloadAsync();
            return new FileStreamResult(response?.Value?.Content, response?.Value?.ContentType);
        }
    }
    ```

1. Wählen Sie **Speichern** aus, um Ihre Änderungen in der Datei **FileParser.cs** zu speichern.

#### <a name="task-4-deploy-and-validate-the-azure-functions-app"></a>Aufgabe 4: Bereitstellen und Überprüfen der Azure Functions-App

1. Wählen Sie auf der Taskleiste das Symbol **Windows-Terminal** aus.

1. Führen Sie den folgenden Befehl aus, um vom aktuellen Verzeichnis in das leere Verzeichnis **Allfiles (F):\\Allfiles\\Labs\\07\\Starter\\func** zu wechseln:

    ```powershell
    cd F:\Allfiles\Labs\07\Starter\func
    ```

1. Führen Sie den folgenden Befehl aus, um sich bei der Azure CLI anzumelden:

    ```powershell
    az login
    ```
1. Geben Sie im **Microsoft Edge**-Browserfenster die E-Mail-Adresse und das Kennwort für Ihr Microsoft-Konto ein, und wählen Sie dann **Anmelden** aus.

1. Kehren Sie zum derzeit geöffneten **Windows-Terminal**-Fenster zurück. Warten Sie, bis der Anmeldevorgang abgeschlossen ist.

1. Führen Sie den folgenden Befehl aus, um das Funktions-App-Projekt erneut zu veröffentlichen:

    ```powershell
    func azure functionapp publish <function-app-name>
    ```

    > **Hinweis**: Wenn Ihr **Funktions-App-Name** beispielsweise **securefuncstudent** lautet, wäre Ihr Befehl ``func azure functionapp publish securefuncstudent``. Sie können die Dokumentation zum [Veröffentlichen des lokalen Funktions-App-Projekts][azure-functions-core-tools-publish-azure] mithilfe der **Azure Functions Core Tools** lesen.

1. Warten Sie, bis die Bereitstellung fertig gestellt ist, bevor Sie mit dem Lab fortfahren.

1. Schließen Sie die aktuell ausgeführte **Windows-Terminal**-Anwendung.

1. Wählen Sie auf der Taskleiste das Symbol **Microsoft Edge** aus, und rufen Sie dann das Azure-Portal (<https://portal.azure.com>) auf.

1. Wählen Sie im Navigationsbereich des Azure-Portals den Link **Ressourcengruppen** aus.

1. Wählen Sie auf dem Blatt **Ressourcengruppen** die Ressourcengruppe **ConfidentialStack** aus.

1. Wählen Sie auf dem Blatt **ConfidentialStack** die Funktions-App **securefunc[Ihr Name]** aus.

1. Wählen Sie auf dem Blatt **App Service** im Abschnitt **Funktionen** die Option **Funktionen** aus.

1. Wählen Sie im Bereich **Funktionen** die vorhandene **FileParser**-Funktion aus.

1. Wählen Sie auf dem Blatt **Funktion** im Abschnitt **Entwickler** die Option **Programmieren und testen** aus.

1. Wählen Sie im Funktionen-Editor **Testen/Ausführen** aus.

1. Wählen Sie im angezeigten Popupdialogfeld in der Liste **HTTP-Methode** die Option **GET** aus.

1. Wählen Sie **Ausführen** aus, um die Funktion zu testen.

1. Sehen Sie sich die Ergebnisse des Testlaufs an. Die Ausgabe enthält den Inhalt des Blobs **$/drop/records.json**, der in Ihrem Azure Storage-Konto gespeichert ist.

#### <a name="review"></a>Überprüfung

In dieser Übung haben Sie C\#-Code verwendet, um auf ein Speicherkonto zuzugreifen, und dann den Inhalt eines Blob heruntergeladen.

### <a name="exercise-5-clean-up-your-subscription"></a>Übung 5: Bereinigen Ihres Abonnements

#### <a name="task-1-open-azure-cloud-shell"></a>Aufgabe 1: Öffnen von Azure Cloud Shell

1. Wählen Sie im Azure-Portal das Symbol **Cloud Shell** (![Cloud Shell-Symbol](./media/az204_lab_CloudShell.png)) aus, um eine neue Bash-Sitzung zu öffnen. Wenn Cloud Shell standardmäßig eine PowerShell-Sitzung verwendet, wählen Sie **PowerShell** und dann im Dropdownmenü **Bash** aus.

    > **Hinweis**: Wenn Sie **Cloud Shell** zum ersten Mal starten, wählen Sie **PowerShell** aus, wenn Sie aufgefordert werden, **Bash** oder **PowerShell** auszuwählen. Wenn die Meldung **You have no storage mounted** (Es ist kein Speicher eingebunden) angezeigt wird, wählen Sie das Abonnement aus, das Sie in diesem Lab verwenden, und wählen Sie dann **Create storage** (Speicher erstellen) aus.

#### <a name="task-2-delete-a-resource-group"></a>Aufgabe 2: Löschen einer Ressourcengruppe

1. Führen Sie im Bereich **Cloud Shell** den folgenden Befehl aus, um die Ressourcengruppe **ConfidentialStack** zu löschen:

    ```bash
    az group delete --name ConfidentialStack --no-wait --yes
    ```

     > **Hinweis**: Der Befehl wird (dem *--nowait*-Parameter entsprechend) asynchron ausgeführt. Dies bedeutet, dass Sie zwar einen weiteren Azure CLI-Befehl in derselben Bash-Sitzung direkt im Anschluss ausführen können, es jedoch einige Minuten dauert, bis die Ressourcengruppen tatsächlich entfernt wurden.

1. Schließen Sie den Bereich **Cloud Shell** im Portal.

#### <a name="task-3-close-the-active-application"></a>Aufgabe 3: Schließen der aktiven Anwendung

- Schließen Sie die aktuell ausgeführte Microsoft Edge-Anwendung.

#### <a name="review"></a>Überprüfung

In dieser Übung haben Sie Ihr Abonnement bereinigt, indem Sie die in diesem Lab verwendeten Ressourcengruppen entfernt haben.
